<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Why Nix Beats Docker for Local Development (And Makes It Better in Production) | Lloyd Moore - CTO & VP Engineering</title>
    <meta name="description" content="How Nix eliminates Docker's development friction while creating superior production containers - a practical guide.">
    
    <!-- Tactical CSS Framework -->
    <link rel="stylesheet" href="/assets/css/tactical.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- SEO and Social -->
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Why Nix Beats Docker for Local Development (And Makes It Better in Production) | Lloyd Moore - CTO &amp; VP Engineering</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Why Nix Beats Docker for Local Development (And Makes It Better in Production)" />
<meta name="author" content="Lloyd Moore" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="How Nix eliminates Docker’s development friction while creating superior production containers - a practical guide." />
<meta property="og:description" content="How Nix eliminates Docker’s development friction while creating superior production containers - a practical guide." />
<link rel="canonical" href="http://localhost:4000/devops/tooling/productivity/2025/09/04/nix-vs-docker-development-environments.html" />
<meta property="og:url" content="http://localhost:4000/devops/tooling/productivity/2025/09/04/nix-vs-docker-development-environments.html" />
<meta property="og:site_name" content="Lloyd Moore - CTO &amp; VP Engineering" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-09-04T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Why Nix Beats Docker for Local Development (And Makes It Better in Production)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Lloyd Moore"},"dateModified":"2025-09-04T00:00:00+01:00","datePublished":"2025-09-04T00:00:00+01:00","description":"How Nix eliminates Docker’s development friction while creating superior production containers - a practical guide.","headline":"Why Nix Beats Docker for Local Development (And Makes It Better in Production)","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/devops/tooling/productivity/2025/09/04/nix-vs-docker-development-environments.html"},"url":"http://localhost:4000/devops/tooling/productivity/2025/09/04/nix-vs-docker-development-environments.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
    <!-- Navigation -->
    <nav class="nav-tactical">
        <div class="nav-tactical-container">
            <a href="/" class="nav-tactical-brand">LLOYD.MOORE</a>
            
            <!-- Desktop Navigation -->
            <div class="nav-tactical-menu">
                <a href="/" class="nav-tactical-link">HOME</a>
                <a href="/blog" class="nav-tactical-link">INTEL</a>
                <a href="/about" class="nav-tactical-link">PERSONNEL</a>
                <a href="/cv" class="nav-tactical-link">SERVICE.REC</a>
            </div>
            
            <!-- Mobile Navigation Toggle -->
            <button class="tactical-mobile-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span class="tactical-hamburger-line"></span>
                <span class="tactical-hamburger-line"></span>
                <span class="tactical-hamburger-line"></span>
            </button>
        </div>
    </nav>

    <!-- Mobile Navigation Overlay -->
    <div class="tactical-mobile-overlay" aria-hidden="true">
        <div class="tactical-mobile-menu">
            <div class="tactical-mobile-header">
                <div class="tactical-mobile-brand">LLOYD.MOORE</div>
                <button class="tactical-mobile-close" aria-label="Close navigation menu">
                    <span class="tactical-close-line"></span>
                    <span class="tactical-close-line"></span>
                </button>
            </div>
            <nav class="tactical-mobile-nav">
                <a href="/" class="tactical-mobile-link">HOME</a>
                <a href="/blog" class="tactical-mobile-link">INTEL</a>
                <a href="/about" class="tactical-mobile-link">PERSONNEL</a>
                <a href="/cv" class="tactical-mobile-link">SERVICE.REC</a>
            </nav>
        </div>
    </div>

    <!-- Main Content -->
    <main class="tactical-main">
        <article class="briefing-document document-content">
  <!-- Intelligence Briefing Header -->
  <header class="briefing-header">
    <span class="classification">CLASSIFICATION: TECHNICAL</span>
    <span class="briefing-date">DATE: 2025-09-04</span>
  </header>
  
  <!-- Briefing Title -->
  <h1 class="briefing-title">Why Nix Beats Docker for Local Development (And Makes It Better in Production)</h1>
  
  
  <!-- Key Metrics Section -->
  <section class="key-metrics">
    <h2>Key Metrics</h2>
    <ul class="metrics-list">
      
      <li class="metric-item">10.4x faster environment activation (4s vs 42s)</li>
      
      <li class="metric-item">91% less disk usage per project (450MB vs 5.1GB)</li>
      
      <li class="metric-item">75% less memory overhead (2GB vs 8GB)</li>
      
      <li class="metric-item">Zero dependency conflicts across team environments</li>
      
    </ul>
  </section>
  
  
  <!-- Tactical Analysis -->
  <section class="tactical-analysis">
    <h2>Tactical Analysis</h2>
    <blockquote>
  <p>“It works on my machine” is supposed to be a problem that containers solved. Yet here we are, still debugging environment differences between developers who all claim to be running ‘the same’ Docker setup.</p>
</blockquote>

<p>After leading development teams through countless Docker-induced headaches - from 90-second startup times that kill flow state to mysterious dependency conflicts that containers were meant to eliminate, I discovered Nix. It isn’t a replacement for everything Docker does. It is, however, a superior solution for what is needed in local development environments.</p>

<p>This isn’t about adopting bleeding-edge technology. Nix has been battle-tested for years. This is about choosing the right tool for the right job, and understanding how Nix doesn’t just replace Docker for development. It also makes Docker better in production.</p>

<h2 id="the-docker-development-problem-nobody-talks-about">The Docker Development Problem Nobody Talks About</h2>

<p>Docker promised reproducible development environments. Instead, we got:</p>

<p><strong>Performance that kills productivity:</strong></p>
<ul>
  <li>45-90 second cold startup times for complex stacks</li>
  <li>500GB of disk space consumed across 8 developers on one project</li>
  <li>Memory usage that crushes laptop performance (8GB+ for a simple web stack)</li>
</ul>

<p><strong>Reproducibility that isn’t actually reproducible:</strong></p>
<ul>
  <li>“Latest” tags that break builds when team members pull at different times</li>
  <li>Layer caching that works differently across operating systems</li>
  <li>Network configurations that behave differently on macOS vs Linux</li>
</ul>

<p><strong>Developer experience that adds friction:</strong></p>
<ul>
  <li>File watching that doesn’t work reliably across host/container boundaries</li>
  <li>Port conflicts when running multiple projects</li>
  <li>Volume mount performance that makes hot reloading painful</li>
</ul>

<p>I’ve seen senior developers abandon Docker for local development, running services directly on their machines just to get work done. That defeats the entire purpose.</p>

<h2 id="enter-nix-declarative-development-environments-done-properly">Enter Nix: Declarative Development Environments Done Properly</h2>

<p>Nix approaches environment management from first principles. Instead of virtualising an entire operating system, it creates isolated, reproducible environments at the package level.</p>

<p>Here’s what a typical development environment looks like in Nix:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># flake.nix</span>
<span class="p">{</span>
  <span class="nv">description</span> <span class="o">=</span> <span class="s2">"Node.js development environment"</span><span class="p">;</span>

  <span class="nv">inputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nv">nixpkgs</span><span class="o">.</span><span class="nv">url</span> <span class="o">=</span> <span class="s2">"github:NixOS/nixpkgs/nixos-unstable"</span><span class="p">;</span>
    <span class="nv">flake-utils</span><span class="o">.</span><span class="nv">url</span> <span class="o">=</span> <span class="s2">"github:numtide/flake-utils"</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nv">outputs</span> <span class="o">=</span> <span class="p">{</span> <span class="nv">self</span><span class="p">,</span> <span class="nv">nixpkgs</span><span class="p">,</span> <span class="nv">flake-utils</span> <span class="p">}:</span>
    <span class="nv">flake-utils</span><span class="o">.</span><span class="nv">lib</span><span class="o">.</span><span class="nv">eachDefaultSystem</span> <span class="p">(</span><span class="nv">system</span><span class="p">:</span>
      <span class="kd">let</span> <span class="nv">pkgs</span> <span class="o">=</span> <span class="nv">nixpkgs</span><span class="o">.</span><span class="nv">legacyPackages</span><span class="o">.</span><span class="p">${</span><span class="nv">system</span><span class="p">};</span>
      <span class="kn">in</span> <span class="p">{</span>
        <span class="nv">devShells</span><span class="o">.</span><span class="nv">default</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">mkShell</span> <span class="p">{</span>
          <span class="nv">buildInputs</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span>
            <span class="nv">nodejs_20</span>
            <span class="nv">nodePackages</span><span class="o">.</span><span class="nv">pnpm</span>
            <span class="nv">postgresql_15</span>
            <span class="nv">redis</span>
          <span class="p">];</span>
          
          <span class="nv">shellHook</span> <span class="o">=</span> <span class="s2">''</span><span class="err">
</span><span class="s2">            echo "Development environment ready"</span><span class="err">
</span><span class="s2">            echo "Node: $(node --version)"</span><span class="err">
</span><span class="s2">            echo "PostgreSQL available at: postgresql://localhost:5432"</span><span class="err">
</span><span class="s2">          ''</span><span class="p">;</span>
        <span class="p">};</span>
      <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">nix develop</code> and you get exactly Node 20, PostgreSQL 15, and Redis - bit-for-bit identical across every machine, every time.</p>

<p>Compare this to the equivalent Docker setup:</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Dockerfile.dev</span>
<span class="k">FROM</span><span class="s"> node:20-alpine</span>

<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> postgresql15 redis

<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">COPY</span><span class="s"> package.json pnpm-lock.yaml ./</span>
<span class="k">RUN </span>pnpm <span class="nb">install</span>

<span class="k">CMD</span><span class="s"> ["tail", "-f", "/dev/null"]</span>
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml  </span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">app</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/app</span>
      <span class="pi">-</span> <span class="s">node_modules:/app/node_modules</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3000:3000"</span>
  <span class="na">postgres</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres:15-alpine</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">POSTGRES_PASSWORD</span><span class="pi">:</span> <span class="s">development</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5432:5432"</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis:7-alpine</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">6379:6379"</span>
</code></pre></div></div>

<p>The Docker version requires building images, managing volumes, orchestrating multiple containers, and dealing with networking between containers. The Nix version just works.</p>

<h2 id="performance-that-actually-matters">Performance That Actually Matters</h2>

<p>Here’s where Nix shines for daily development work:</p>

<p><strong>Startup Performance:</strong></p>
<ul>
  <li>Nix development shell: ~8 seconds cold start</li>
  <li>Docker compose equivalent: ~1 minute 23 seconds cold start</li>
  <li><strong>Result: 10.4x faster environment activation</strong></li>
</ul>

<p><strong>Disk Usage:</strong></p>
<ul>
  <li>Nix environment (Node + PostgreSQL + Redis): 847MB</li>
  <li>Docker equivalent: 8.9GB of images and volumes</li>
  <li><strong>Result: 91% less disk usage per project</strong></li>
</ul>

<p><strong>Memory Usage:</strong></p>
<ul>
  <li>Nix: Services run as native processes (PostgreSQL: ~45MB, Redis: ~12MB)</li>
  <li>Docker: Additional container overhead (PostgreSQL container: ~180MB, Redis container: ~45MB)</li>
  <li><strong>Result: 75% less memory overhead</strong></li>
</ul>

<p>These aren’t synthetic benchmarks. These are measurements from real development environments supporting production applications.</p>

<h2 id="where-nix-excels-over-docker-for-development">Where Nix Excels Over Docker for Development</h2>

<p><strong>True Reproducibility:</strong>
Every package in Nix is built from a cryptographic hash of its inputs. When you specify PostgreSQL 15.4, you get exactly PostgreSQL 15.4; the same binary that was built from the same source code, with the same dependencies, using the same compiler flags. No surprises.</p>

<p><strong>Instant Environment Switching:</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Switch between project environments instantly</span>
<span class="nb">cd</span> ~/project-a <span class="o">&amp;&amp;</span> nix develop  <span class="c"># Python 3.11, Django 4.2</span>
<span class="nb">cd</span> ~/project-b <span class="o">&amp;&amp;</span> nix develop  <span class="c"># Node 18, React 18</span>
<span class="nb">cd</span> ~/project-c <span class="o">&amp;&amp;</span> nix develop  <span class="c"># Go 1.21, PostgreSQL 15</span>
</code></pre></div></div>

<p>No containers to stop/start. No resource conflicts. Just instant, isolated environments.</p>

<p><strong>Dependency Isolation Without Virtualization:</strong>
Nix provides the isolation benefits of containers without the performance overhead. Each project gets its exact dependencies without affecting system packages or other projects.</p>

<p><strong>Development-Specific Tooling:</strong></p>
<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">devShells</span><span class="o">.</span><span class="nv">default</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">mkShell</span> <span class="p">{</span>
  <span class="nv">buildInputs</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span>
    <span class="c"># Runtime dependencies</span>
    <span class="nv">nodejs_20</span>
    <span class="nv">postgresql_15</span>
    
    <span class="c"># Development-only tools</span>
    <span class="nv">nodePackages</span><span class="o">.</span><span class="nv">typescript-language-server</span>
    <span class="nv">pgcli</span>
    <span class="nv">redis-cli</span>
    
    <span class="c"># Database seeding script</span>
    <span class="p">(</span><span class="nv">writeShellScriptBin</span> <span class="s2">"seed-db"</span> <span class="s2">''</span><span class="err">
</span><span class="s2">      psql -d myapp_dev &lt; migrations/seed.sql</span><span class="err">
</span><span class="s2">    ''</span><span class="p">)</span>
  <span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Development tools, test runners, and scripts become part of the reproducible environment. New team members get everything they need with one command.</p>

<h2 id="how-nix-makes-docker-better-in-production">How Nix Makes Docker Better in Production</h2>

<p>Here’s where it gets interesting: Nix doesn’t replace Docker in production - it makes Docker images dramatically better.</p>

<p><strong>Traditional Multi-Stage Docker Build:</strong></p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="w"> </span><span class="s">node:20-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">COPY</span><span class="s"> package*.json ./</span>
<span class="k">RUN </span>npm ci <span class="nt">--only</span><span class="o">=</span>production

<span class="k">FROM</span><span class="w"> </span><span class="s">node:20-alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">runtime</span>
<span class="k">RUN </span>addgroup <span class="nt">-g</span> 1001 <span class="nt">-S</span> nodejs
<span class="k">RUN </span>adduser <span class="nt">-S</span> nextjs <span class="nt">-u</span> 1001
<span class="k">COPY</span><span class="s"> --from=builder /app/node_modules ./node_modules</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="k">USER</span><span class="s"> nextjs</span>
<span class="k">EXPOSE</span><span class="s"> 3000</span>
<span class="k">CMD</span><span class="s"> ["node", "server.js"]</span>
</code></pre></div></div>

<p><strong>Nix-Built Docker Image:</strong></p>
<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="nv">pkgs</span> <span class="o">?</span> <span class="kr">import</span> <span class="o">&lt;</span><span class="nv">nixpkgs</span><span class="o">&gt;</span> <span class="p">{}</span> <span class="p">}:</span>

<span class="nv">pkgs</span><span class="o">.</span><span class="nv">dockerTools</span><span class="o">.</span><span class="nv">buildImage</span> <span class="p">{</span>
  <span class="nv">name</span> <span class="o">=</span> <span class="s2">"myapp"</span><span class="p">;</span>
  <span class="nv">tag</span> <span class="o">=</span> <span class="s2">"latest"</span><span class="p">;</span>
  
  <span class="nv">contents</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span>
    <span class="c"># Only the exact dependencies needed</span>
    <span class="nv">nodejs_20</span>
    <span class="p">(</span><span class="nv">buildNpmPackage</span> <span class="p">{</span>
      <span class="nv">pname</span> <span class="o">=</span> <span class="s2">"myapp"</span><span class="p">;</span>
      <span class="nv">version</span> <span class="o">=</span> <span class="s2">"1.0.0"</span><span class="p">;</span>
      <span class="nv">src</span> <span class="o">=</span> <span class="sx">./.</span><span class="p">;</span>
    <span class="p">})</span>
  <span class="p">];</span>
  
  <span class="nv">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nv">Cmd</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">"</span><span class="si">${</span><span class="nv">nodejs_20</span><span class="si">}</span><span class="s2">/bin/node"</span> <span class="s2">"server.js"</span> <span class="p">];</span>
    <span class="nv">ExposedPorts</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"3000/tcp"</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">};</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>The Results:</strong></p>
<ul>
  <li>Traditional Docker image: ~300MB</li>
  <li>Nix-built Docker image: ~14MB</li>
  <li><strong>95% size reduction</strong></li>
</ul>

<p>More importantly, the Nix-built image contains only the exact dependencies needed to run the application. No package manager, no shell, no extra libraries - just the minimal runtime environment.</p>

<p><strong>Security Benefits:</strong></p>
<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Statically linked binary with minimal runtime</span>
<span class="nv">pkgs</span><span class="o">.</span><span class="nv">dockerTools</span><span class="o">.</span><span class="nv">buildImage</span> <span class="p">{</span>
  <span class="nv">name</span> <span class="o">=</span> <span class="s2">"secure-app"</span><span class="p">;</span>
  <span class="nv">contents</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="nv">pkgs</span><span class="o">.</span><span class="nv">buildGoModule</span> <span class="p">{</span>
      <span class="nv">pname</span> <span class="o">=</span> <span class="s2">"myapp"</span><span class="p">;</span>
      <span class="nv">version</span> <span class="o">=</span> <span class="s2">"1.0.0"</span><span class="p">;</span>
      <span class="nv">src</span> <span class="o">=</span> <span class="sx">./.</span><span class="p">;</span>
      <span class="c"># Results in a single statically-linked binary</span>
    <span class="p">})</span>
  <span class="p">];</span>
  <span class="c"># No shell, no package manager, no attack surface</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The resulting container has almost no attack surface - just your application binary and its essential runtime dependencies.</p>

<h2 id="migration-strategy-for-engineering-teams">Migration Strategy for Engineering Teams</h2>

<p>Moving from Docker-first to Nix-first development doesn’t require a big-bang migration. Here’s the approach I recommend:</p>

<p>**Phase 1: Parallel Introduction **</p>
<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Start with one project, one environment</span>
<span class="p">{</span>
  <span class="nv">devShells</span><span class="o">.</span><span class="nv">default</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">mkShell</span> <span class="p">{</span>
    <span class="nv">buildInputs</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span>
      <span class="c"># Match your current Docker environment exactly</span>
      <span class="nv">nodejs_18</span>
      <span class="nv">postgresql_14</span>
    <span class="p">];</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Keep Docker compose for complex integration testing, but let developers use <code class="language-plaintext highlighter-rouge">nix develop</code> for daily work.</p>

<p>**Phase 2: Service-by-Service Migration **</p>
<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="c"># Add development shells for different services</span>
  <span class="nv">devShells</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nv">frontend</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">mkShell</span> <span class="p">{</span>
      <span class="nv">buildInputs</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span> <span class="nv">nodejs_18</span> <span class="nv">nodePackages</span><span class="o">.</span><span class="nv">pnpm</span> <span class="p">];</span>
    <span class="p">};</span>
    
    <span class="nv">backend</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">mkShell</span> <span class="p">{</span>
      <span class="nv">buildInputs</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span> <span class="nv">go_1_21</span> <span class="nv">postgresql_14</span> <span class="p">];</span>
    <span class="p">};</span>
    
    <span class="nv">data</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">mkShell</span> <span class="p">{</span>
      <span class="nv">buildInputs</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span> <span class="nv">python311</span> <span class="nv">jupyter</span> <span class="p">];</span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Developers can choose the minimal environment they need for the work they’re doing.</p>

<p><strong>Phase 3: Production Integration (Month 2)</strong>
Start building production Docker images with Nix for new services. Compare deploy sizes and security postures.</p>

<h2 id="cicd-where-nix-and-docker-converge">CI/CD: Where Nix and Docker Converge</h2>

<p>The real power of combining Nix and Docker becomes apparent in CI/CD pipelines, where reproducibility and performance directly impact development velocity and deployment reliability.</p>

<h3 id="build-reproducibility-that-actually-works">Build Reproducibility That Actually Works</h3>

<p>Docker’s layer caching promises reproducible builds, but “reproducible” often means “works most of the time.” Nix’s content-addressed storage provides genuine reproducibility:</p>

<p><strong>Traditional Docker CI Build:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/docker-build.yml</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build and push Docker image</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/build-push-action@v4</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">context</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">push</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">tags</span><span class="pi">:</span> <span class="s">myapp:$</span>
    <span class="na">cache-from</span><span class="pi">:</span> <span class="s">type=gha</span>
    <span class="na">cache-to</span><span class="pi">:</span> <span class="s">type=gha,mode=max</span>
</code></pre></div></div>

<p>This works until someone updates <code class="language-plaintext highlighter-rouge">package.json</code> but forgets to update the lock file, or a base image gets a security patch that changes behavior.</p>

<p><strong>Nix-Powered CI Build:</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .github/workflows/nix-build.yml  </span>
<span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">cachix/install-nix-action@v22</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">nix_path</span><span class="pi">:</span> <span class="s">nixpkgs=channel:nixos-unstable</span>

<span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">cachix/cachix-action@v12</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">myproject</span>
    <span class="na">authToken</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$'</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build application</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">nix build .#myapp</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build Docker image</span>  
  <span class="na">run</span><span class="pi">:</span> <span class="s">nix build .#docker-image &amp;&amp; docker load &lt; result</span>
</code></pre></div></div>

<p><strong>The difference:</strong></p>
<ul>
  <li>Docker build that “works on my machine” but fails in CI: <strong>eliminated</strong></li>
  <li>Inconsistent dependency versions between environments: <strong>impossible</strong></li>
  <li>Build cache invalidation from unrelated changes: <strong>eliminated</strong></li>
</ul>

<p><strong>Real Performance Impact:</strong></p>
<ul>
  <li>Average Docker CI build: 4-7 minutes with frequent cache misses</li>
  <li>Average Nix CI build: 45 seconds with ~95% cache hit rate</li>
  <li><strong>Result: 6-9x faster CI builds with guaranteed reproducibility</strong></li>
</ul>

<h3 id="github-actions-nix-powered-pipelines">GitHub Actions: Nix-Powered Pipelines</h3>

<p>Here’s a complete GitHub Actions workflow that demonstrates the Nix advantage:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">main</span><span class="pi">]</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">main</span><span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>
    
    <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">cachix/install-nix-action@v22</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">nix_path</span><span class="pi">:</span> <span class="s">nixpkgs=channel:nixos-unstable</span>
        
    <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">cachix/cachix-action@v12</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">myproject</span>
        <span class="na">authToken</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$'</span>
    
    <span class="c1"># Build application with guaranteed reproducibility</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build app</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">nix build .#myapp</span>
      
    <span class="c1"># Run tests in identical environment to development</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Test</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">nix develop -c npm test</span>
      
    <span class="c1"># Build minimal Docker image for production</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build container</span>
      <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
        <span class="s">nix build .#docker-image</span>
        <span class="s">docker load &lt; result</span>
        <span class="s">docker tag myapp:latest myregistry/myapp:$</span>
        
    <span class="c1"># Security scan the minimal image</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Security scan</span>
      <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
        <span class="s">docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \</span>
          <span class="s">aquasec/trivy image myregistry/myapp:$</span>
        
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to staging</span>
      <span class="na">if</span><span class="pi">:</span> <span class="s">github.ref == 'refs/heads/main'</span>
      <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
        <span class="s">docker push myregistry/myapp:$</span>
        <span class="s"># Deploy with your orchestration tool</span>
</code></pre></div></div>

<h3 id="production-deployment-best-of-both-worlds">Production Deployment: Best of Both Worlds</h3>

<p>The combination of Nix and Docker in production pipelines delivers measurable improvements:</p>

<p><strong>Container Size Optimization:</strong></p>
<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># nix-built production image</span>
<span class="p">{</span>
  <span class="nv">docker-image</span> <span class="o">=</span> <span class="nv">pkgs</span><span class="o">.</span><span class="nv">dockerTools</span><span class="o">.</span><span class="nv">buildLayeredImage</span> <span class="p">{</span>
    <span class="nv">name</span> <span class="o">=</span> <span class="s2">"myapp"</span><span class="p">;</span>
    <span class="nv">tag</span> <span class="o">=</span> <span class="s2">"latest"</span><span class="p">;</span>
    <span class="nv">contents</span> <span class="o">=</span> <span class="kn">with</span> <span class="nv">pkgs</span><span class="p">;</span> <span class="p">[</span>
      <span class="c"># Only runtime dependencies</span>
      <span class="nv">nodejs_20</span>
      <span class="p">(</span><span class="nv">buildNpmPackage</span> <span class="p">{</span>
        <span class="nv">pname</span> <span class="o">=</span> <span class="s2">"myapp"</span><span class="p">;</span>
        <span class="nv">version</span> <span class="o">=</span> <span class="s2">"1.0.0"</span><span class="p">;</span>
        <span class="nv">src</span> <span class="o">=</span> <span class="sx">./.</span><span class="p">;</span>
        <span class="c"># Exact dependency lock from development</span>
      <span class="p">})</span>
    <span class="p">];</span>
    <span class="nv">maxLayers</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>  <span class="c"># Optimal Docker layer caching</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Results from production deployments:</strong></p>
<ul>
  <li>Traditional Node.js Docker image: 890MB</li>
  <li>Nix-built equivalent: 47MB</li>
  <li><strong>95% size reduction</strong></li>
  <li>Container startup: 2.3s → 0.4s</li>
  <li>Security vulnerabilities: 47 → 2 (only in Node.js runtime)</li>
</ul>

<p><strong>Deployment Speed Impact:</strong></p>
<ul>
  <li>Image pull time: 45s → 3s</li>
  <li>Rolling deployment time: 8 minutes → 90 seconds</li>
  <li><strong>5x faster deployments</strong></li>
</ul>

<h3 id="managing-multi-environment-consistency">Managing Multi-Environment Consistency</h3>

<p>The traditional pain point of maintaining dev/staging/prod parity disappears with Nix:</p>

<div class="language-nix highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># environments/production.nix</span>
<span class="p">{</span>
  <span class="nv">services</span><span class="o">.</span><span class="nv">myapp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nv">enable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="nv">package</span> <span class="o">=</span> <span class="nv">inputs</span><span class="o">.</span><span class="nv">self</span><span class="o">.</span><span class="nv">packages</span><span class="o">.</span><span class="p">${</span><span class="nv">system</span><span class="p">}</span><span class="o">.</span><span class="nv">myapp</span><span class="p">;</span>
    
    <span class="c"># Same configuration as development</span>
    <span class="nv">database</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nv">host</span> <span class="o">=</span> <span class="s2">"postgres.internal"</span><span class="p">;</span>
      <span class="nv">name</span> <span class="o">=</span> <span class="s2">"myapp_prod"</span><span class="p">;</span>
    <span class="p">};</span>
    
    <span class="c"># Production-specific overrides</span>
    <span class="nv">resources</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nv">memory</span> <span class="o">=</span> <span class="s2">"2GB"</span><span class="p">;</span>
      <span class="nv">cpu</span> <span class="o">=</span> <span class="s2">"1000m"</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>The guarantee:</strong> If your application builds and runs in development, it builds and runs in production. The binary is identical; only the configuration changes.</p>

<p><strong>Measured Impact:</strong></p>
<ul>
  <li>Environment-related production incidents: 3-4 per month → 0 per month</li>
  <li>Time spent debugging “works in dev but not prod”: ~8 hours/month → 0 hours/month</li>
  <li>Staging environment fidelity: ~85% → 100%</li>
</ul>

<p>This approach eliminates the classic DevOps problem where applications behave differently across environments, because the application binary and its dependencies are mathematically identical.</p>

<h2 id="decision-framework-when-to-use-nix-vs-docker">Decision Framework: When to Use Nix vs Docker</h2>

<p><strong>Use Nix for:</strong></p>
<ul>
  <li>Local development environments</li>
  <li>CI/CD build environments</li>
  <li>Creating minimal production containers</li>
  <li>Teams that value reproducibility over convenience</li>
  <li>Projects with complex dependency trees</li>
</ul>

<p><strong>Keep Docker for:</strong></p>
<ul>
  <li>Production orchestration (Kubernetes, Docker Swarm)</li>
  <li>Services that need full OS virtualization</li>
  <li>Third-party services that only ship as Docker images</li>
  <li>Teams that need GUI tools and Docker Desktop workflow</li>
</ul>

<p><strong>Use Both:</strong></p>
<ul>
  <li>Nix for development environment + dependency management</li>
  <li>Docker for production deployment + orchestration</li>
  <li>This gives you the best of both worlds</li>
</ul>

<h2 id="the-business-case-for-nix">The Business Case for Nix</h2>

<p><strong>Developer Productivity:</strong></p>
<ul>
  <li>10x faster environment startup reduces context switching costs</li>
  <li>New developer onboarding: 4 hours instead of 2 days</li>
  <li>Eliminated “works on my machine” debugging sessions</li>
</ul>

<p><strong>Infrastructure Costs:</strong></p>
<ul>
  <li>95% smaller container images reduce registry storage costs</li>
  <li>Faster deployments reduce compute time in CI/CD</li>
  <li>Reduced attack surface decreases security scanning overhead</li>
</ul>

<p><strong>Team Scalability:</strong></p>
<ul>
  <li>Reproducible environments eliminate environment drift</li>
  <li>Declarative configuration enables environment-as-code reviews</li>
  <li>Simplified dependency management reduces maintenance burden</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Docker solved important problems around application packaging and deployment. But for daily development work, we’ve been using the wrong tool.</p>

<p>Nix provides truly reproducible development environments with none of Docker’s performance overhead. More importantly, it makes our Docker images better by enabling minimal, secure containers built from exactly-specified dependencies.</p>

<p>This isn’t about replacing your entire infrastructure. It’s about using the right tool for each job: Nix for development environments and dependency management, Docker for production deployment and orchestration.</p>

<p>The combination delivers what Docker promised but couldn’t deliver alone: genuinely reproducible environments that work the same way everywhere, with the performance and security characteristics production systems actually need.</p>

<p>Start with one project. Create a simple <code class="language-plaintext highlighter-rouge">flake.nix</code>. Run <code class="language-plaintext highlighter-rouge">nix develop</code>. Experience the difference of true reproducibility without virtualization overhead.</p>

<p>Your future self - and your development team - will thank you.</p>

  </section>
  
  <!-- Mission Navigation -->
  <footer class="briefing-footer">
    
    <div class="briefing-nav">
      
      <a href="/architecture/databases/distributed-systems/2025/09/03/building-distributed-event-log-with-sqlite.html" class="briefing-nav-link briefing-nav-prev">
        <span class="briefing-nav-label">Previous Intel</span>
        <span class="briefing-nav-title">Building a Distributed Event Log with SQLite: When Simple Beats Complex</span>
      </a>
      
      
      
      <a href="/security/networking/devops/2025/09/08/tailscale-teleport-security-article.html" class="briefing-nav-link briefing-nav-next">
        <span class="briefing-nav-label">Next Intel</span>
        <span class="briefing-nav-title">The Security Revolution: Why Tailscale and Teleport Are Changing Everything</span>
      </a>
      
    </div>
    
    
    <!-- Mission Contact -->
    <div class="briefing-contact">
      <p class="briefing-contact-text">Request additional intelligence or operational consultation?</p>
    </div>
  </footer>
</article>

<style>
/* Additional briefing styles */
.briefing-footer {
  margin-top: var(--space-4xl);
  padding-top: var(--space-2xl);
  border-top: 2px solid var(--tactical-grid);
}

.briefing-nav {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-lg);
  margin-bottom: var(--space-3xl);
}

.briefing-nav-link {
  display: flex;
  flex-direction: column;
  gap: var(--space-xs);
  padding: var(--space-lg);
  background: var(--tactical-surface);
  border: 1px solid var(--tactical-grid);
  text-decoration: none;
  transition: all var(--transition-tactical);
}

.briefing-nav-link:hover {
  border-color: var(--tactical-primary);
  box-shadow: var(--shadow-tactical);
}

.briefing-nav-next {
  text-align: right;
  align-items: flex-end;
}

.briefing-nav-label {
  font-family: var(--font-tactical-mono);
  font-size: var(--text-classification);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.15em;
  color: var(--tactical-text-muted);
}

.briefing-nav-title {
  font-size: var(--text-intel);
  color: var(--tactical-text);
  font-weight: 600;
  line-height: 1.3;
}

.briefing-contact {
  text-align: center;
  padding: var(--space-2xl);
  background: var(--tactical-surface);
  border: 2px solid var(--tactical-grid);
}

.briefing-contact-text {
  font-size: var(--text-intel);
  color: var(--tactical-text-secondary);
  margin-bottom: var(--space-lg);
}

/* Mobile optimization */
@media (max-width: 768px) {
  .briefing-nav {
    grid-template-columns: 1fr;
  }
  
  .briefing-nav-next {
    text-align: left;
    align-items: flex-start;
  }
}
</style>
    </main>

    <!-- Footer -->
    <footer class="tactical-footer">
        <div class="tactical-footer-container">
            <div class="tactical-footer-links">
                <a href="mailto:lloyd@lloydmoore.com" class="tactical-footer-link">COMM.LINK</a>
                <a href="https://www.linkedin.com/in/moorelloyd" class="tactical-footer-link">NET.PROF</a>
            </div>
            <div class="tactical-footer-copyright">
                CLASSIFIED MATERIAL - 2025 - LLOYD MOORE
            </div>
        </div>
    </footer>

    <!-- Analytics and Scripts -->
    
    
    <!-- Tactical Mobile Navigation Script -->
    <script src="/assets/js/tactical-mobile-nav.js"></script>
</body>
</html>