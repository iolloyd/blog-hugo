<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>How TLA&#43; Formal Verification Caught a Production Bug Before It Shipped | Lloyd Moore</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="A real-world case study of using formal methods to find a subtle race condition in a CV matching system that traditional testing missed.">
    <meta name="generator" content="Hugo 0.150.0">
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.2438bcafd7af9675c426d1a4afcd16cfff18e4e10f401071e45b5ccd3be40a0d.css" >




    


    
      

    

    

    
      <link rel="canonical" href="https://lloydmoore.com/posts/2025-08-28-tlaplus-not-just-concurrency/">
    

    <meta property="og:url" content="https://lloydmoore.com/posts/2025-08-28-tlaplus-not-just-concurrency/">
  <meta property="og:site_name" content="Lloyd Moore">
  <meta property="og:title" content="How TLA&#43; Formal Verification Caught a Production Bug Before It Shipped">
  <meta property="og:description" content="A real-world case study of using formal methods to find a subtle race condition in a CV matching system that traditional testing missed.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-28T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-08-28T00:00:00+00:00">
    <meta property="article:tag" content="Tlaplus">
    <meta property="article:tag" content="Formal-Verification">
    <meta property="article:tag" content="Concurrency">
    <meta property="article:tag" content="Testing">
    <meta property="article:tag" content="Software-Engineering">

  <meta itemprop="name" content="How TLA&#43; Formal Verification Caught a Production Bug Before It Shipped">
  <meta itemprop="description" content="A real-world case study of using formal methods to find a subtle race condition in a CV matching system that traditional testing missed.">
  <meta itemprop="datePublished" content="2025-08-28T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-08-28T00:00:00+00:00">
  <meta itemprop="wordCount" content="1343">
  <meta itemprop="keywords" content="Tlaplus,Formal-Verification,Concurrency,Testing,Software-Engineering">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="How TLA&#43; Formal Verification Caught a Production Bug Before It Shipped">
  <meta name="twitter:description" content="A real-world case study of using formal methods to find a subtle race condition in a CV matching system that traditional testing missed.">

      
    
	
  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Lloyd Moore
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">How TLA&#43; Formal Verification Caught a Production Bug Before It Shipped</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2025-08-28T00:00:00Z">August 28, 2025</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><em>How we caught a production bug before it shipped using formal verification</em></p>
<hr>
<p>I tried TLA+ formal verification on our recruitment system. It started as an experiment. It ended up saving us from a nasty production bug.</p>
<p>The verification caught a race condition that would have corrupted our data. Our code reviews missed it. Our unit tests missed it. Our integration tests missed it too.</p>
<p>Here&rsquo;s how mathematical proof succeeded where traditional testing failed.</p>
<h2 id="the-system-cv-job-matching-at-scale">The System: CV Job Matching at Scale</h2>
<p>We built a recruitment platform that processes PDF CVs and matches candidates to jobs. Think mini-LinkedIn for recruiters. It has four main parts:</p>
<ul>
<li><strong>PDF Processing Pipeline</strong>: Extracts data from uploaded CVs</li>
<li><strong>Multi-Stage Matching Engine</strong>: Scores candidates against jobs</li>
<li><strong>Job Lifecycle Management</strong>: Handles job states (draft → active → inactive)</li>
<li><strong>REST API</strong>: Manages uploads, matching requests, and results</li>
</ul>
<p>The architecture looked solid. We had unit tests. We had integration tests. I&rsquo;d reviewed all the code myself. What could go wrong?</p>
<h2 id="enter-tla-formal-verification-for-the-masses">Enter TLA+: Formal Verification for the Masses</h2>
<p><a href="https://lamport.azurewebsites.net/tla/tla.html">TLA+ (Temporal Logic of Actions)</a> is Leslie Lamport&rsquo;s language for modeling concurrent systems. Testing checks specific scenarios. TLA+ is different. It mathematically explores <em>every possible execution</em> of your system.</p>
<p>I spent a day writing TLA+ specifications for our matching system. Here&rsquo;s what they looked like:</p>
<pre tabindex="0"><code class="language-tla" data-lang="tla">\* CV Processing State Machine
StartCVProcessing ==
    \E c \in Candidates:
        /\ candidateStatus[c] = &#34;uploaded&#34;
        /\ candidateStatus&#39; = [candidateStatus EXCEPT ![c] = &#34;processing&#34;]

\* Job Lifecycle Management  
DeactivateJob ==
    \E j \in Jobs:
        /\ jobStatus[j] = &#34;active&#34;
        /\ jobStatus&#39; = [jobStatus EXCEPT ![j] = &#34;inactive&#34;]

\* Matching Algorithm
StartMatching ==
    \E c \in Candidates, j \in Jobs:
        /\ candidateStatus[c] = &#34;completed&#34; 
        /\ jobStatus[j] = &#34;active&#34;
        /\ matchingInProgress&#39; = matchingInProgress \cup {&lt;&lt;c, j&gt;&gt;}
</code></pre><p>The specifications included safety properties (things that must always be true) and liveness properties (things that must eventually happen). One key rule was:</p>
<pre tabindex="0"><code class="language-tla" data-lang="tla">\* Matching only occurs between completed candidates and active jobs
MatchingPreconditions ==
    \A pair \in matchingInProgress:
        candidateStatus[pair[1]] = &#34;completed&#34; /\ jobStatus[pair[2]] = &#34;active&#34;
</code></pre><p>This seemed obviously correct. How could we match a candidate with an inactive job? Impossible, right?</p>
<h2 id="the-smoking-gun-tlc-model-checker-finds-the-bug">The Smoking Gun: TLC Model Checker Finds the Bug</h2>
<p>I ran the TLC model checker. It found a violation immediately:</p>
<pre tabindex="0"><code>Error: Invariant MatchingPreconditions is violated.

State 1: Job j1 active, no matches in progress
State 2: Matching starts between candidate c1 and job j1  
State 3: Job j1 deactivated while matching still in progress
Result: matchingInProgress = {&lt;&lt;c1, j1&gt;&gt;} but jobStatus[j1] = &#34;inactive&#34;
</code></pre><p><strong>Wait, what?</strong></p>
<p>The model checker found this execution sequence:</p>
<ol>
<li>A candidate completes CV processing ✅</li>
<li>A job is activated ✅</li>
<li>Matching starts between the candidate and job ✅</li>
<li><strong>The job gets deactivated while matching is still running</strong> ❌</li>
<li>Now we have active matching for an inactive job ❌</li>
</ol>
<h2 id="the-race-condition-explained">The Race Condition Explained</h2>
<p>We had a classic race condition in our job lifecycle management. Our <code>DeactivateJob</code> function looked innocent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Simplified version of our original code</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">DeactivateJob</span>(<span style="color:#a6e22e">jobID</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">Model</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Job</span>{}).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Where</span>(<span style="color:#e6db74">&#34;id = ? AND status = &#39;active&#39;&#34;</span>, <span style="color:#a6e22e">jobID</span>).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Update</span>(<span style="color:#e6db74">&#34;status&#34;</span>, <span style="color:#e6db74">&#34;inactive&#34;</span>).<span style="color:#a6e22e">Error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But it had no synchronization with the matching engine! Here&rsquo;s what happens in production:</p>
<pre tabindex="0"><code>Thread 1 (Matching):     Thread 2 (Job Management):
┌─ Start matching       │
│  candidate C1 with    │
│  job J1 (active)      │
│                       ├─ Admin deactivates job J1
│                       │  (status = &#34;inactive&#34;) 
│                       │
├─ Calculate scores     │  ❌ Job is now inactive but
│  (expensive operation)│     matching continues!
│                       │
├─ Store match results  │  ❌ Results saved for 
   for inactive job J1  │     inactive job!
</code></pre><p>This causes problems:</p>
<ul>
<li><strong>Data inconsistency</strong>: Match results for inactive jobs in the database</li>
<li><strong>Resource waste</strong>: CPU cycles on pointless calculations</li>
<li><strong>User confusion</strong>: Matches appear for jobs that were deactivated</li>
<li><strong>Business rule violations</strong>: We break our core rule &ldquo;only active jobs get matched&rdquo;</li>
</ul>
<h2 id="the-fix-proper-synchronization">The Fix: Proper Synchronization</h2>
<p>TLA+ showed us the problem. The fix became obvious. I implemented two approaches:</p>
<h3 id="approach-1-safe-deactivation-primary">Approach 1: Safe Deactivation (Primary)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">DeactivateJob</span>(<span style="color:#a6e22e">jobID</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">Begin</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Rollback</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check for in-progress matching</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">count</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Model</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MatchingProcess</span>{}).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Where</span>(<span style="color:#e6db74">&#34;job_id = ? AND status = &#39;in_progress&#39;&#34;</span>, <span style="color:#a6e22e">jobID</span>).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Count</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">count</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">count</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ErrMatchingInProgress</span>  <span style="color:#75715e">// Block deactivation</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Safe to deactivate</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Model</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Job</span>{}).<span style="color:#a6e22e">Where</span>(<span style="color:#e6db74">&#34;id = ?&#34;</span>, <span style="color:#a6e22e">jobID</span>).<span style="color:#a6e22e">Update</span>(<span style="color:#e6db74">&#34;status&#34;</span>, <span style="color:#e6db74">&#34;inactive&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Commit</span>().<span style="color:#a6e22e">Error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="approach-2-force-deactivation-with-cleanup-fallback">Approach 2: Force Deactivation with Cleanup (Fallback)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ForceDeactivateJob</span>(<span style="color:#a6e22e">jobID</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">Begin</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Rollback</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Cancel in-progress matches first</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Model</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MatchingProcess</span>{}).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Where</span>(<span style="color:#e6db74">&#34;job_id = ? AND status = &#39;in_progress&#39;&#34;</span>, <span style="color:#a6e22e">jobID</span>).
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Update</span>(<span style="color:#e6db74">&#34;status&#34;</span>, <span style="color:#e6db74">&#34;cancelled&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Then deactivate job</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Model</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Job</span>{}).<span style="color:#a6e22e">Where</span>(<span style="color:#e6db74">&#34;id = ?&#34;</span>, <span style="color:#a6e22e">jobID</span>).<span style="color:#a6e22e">Update</span>(<span style="color:#e6db74">&#34;status&#34;</span>, <span style="color:#e6db74">&#34;inactive&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">tx</span>.<span style="color:#a6e22e">Commit</span>().<span style="color:#a6e22e">Error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The TLA+ specification for the fix:</p>
<pre tabindex="0"><code class="language-tla" data-lang="tla">SafeDeactivateJob ==
    \E j \in Jobs:
        /\ jobStatus[j] = &#34;active&#34;
        \* GUARD: Cannot deactivate job while matching is in progress
        /\ \A pair \in matchingInProgress: pair[2] # j
        /\ jobStatus&#39; = [jobStatus EXCEPT ![j] = &#34;inactive&#34;]
</code></pre><h2 id="verification-results-from-bug-to-bulletproof">Verification Results: From Bug to Bulletproof</h2>
<p>I implemented the fix and re-ran TLA+ verification:</p>
<p><strong>Before Fix</strong>: ❌ <code>MatchingPreconditions</code> invariant violated<br>
<strong>After Fix</strong>: ✅ All invariants maintained across all reachable states</p>
<pre tabindex="0"><code>Model checking completed. No error has been found.
6 states generated, 3 distinct states found, 0 states left on queue.
</code></pre><p>Mathematical proof confirmed our fix worked.</p>
<h2 id="why-traditional-testing-missed-this">Why Traditional Testing Missed This</h2>
<p>This bug shows why race conditions are so nasty:</p>
<ol>
<li><strong>Timing-dependent</strong>: The bug only happens when deactivation occurs during active matching</li>
<li><strong>Non-deterministic</strong>: Even concurrent tests might miss the exact timing</li>
<li><strong>Subtle symptoms</strong>: The system doesn&rsquo;t crash - it just corrupts data</li>
<li><strong>Complex setup</strong>: Requires specific event sequencing across multiple components</li>
</ol>
<p>Our test suite included:</p>
<ul>
<li>✅ Unit tests for job deactivation (passed)</li>
<li>✅ Unit tests for matching algorithm (passed)</li>
<li>✅ Integration tests for the complete flow (passed)</li>
<li>❌ <strong>No tests for concurrent job state changes during matching</strong></li>
</ul>
<p>TLA+ found it immediately. Formal verification explores <em>all possible interleavings</em> of concurrent operations. Not just the ones we thought to test.</p>
<h2 id="the-broader-lesson-formal-methods-in-practice">The Broader Lesson: Formal Methods in Practice</h2>
<p>This experience changed how I think about formal verification. Here&rsquo;s what I learned:</p>
<h3 id="when-tla-shines">When TLA+ Shines</h3>
<ul>
<li><strong>Concurrent systems</strong>: Race conditions, deadlocks, liveness issues</li>
<li><strong>State machines</strong>: Complex state transitions with multiple actors</li>
<li><strong>Critical invariants</strong>: Properties that must <em>always</em> hold</li>
<li><strong>Design validation</strong>: Catching flaws before you implement them</li>
</ul>
<h3 id="when-tla-is-overkill">When TLA+ Is Overkill</h3>
<ul>
<li><strong>Pure algorithms</strong>: Single-threaded computation (use property-based testing)</li>
<li><strong>Simple CRUD apps</strong>: Minimal concurrency or state management</li>
<li><strong>UI logic</strong>: User interaction flows (use integration testing)</li>
<li><strong>Performance issues</strong>: TLA+ models correctness, not speed</li>
</ul>
<h3 id="practical-integration">Practical Integration</h3>
<p>You don&rsquo;t need to verify everything. Start with:</p>
<ol>
<li><strong>Critical business logic</strong>: Core algorithms and state machines</li>
<li><strong>Concurrency hotspots</strong>: Areas with multiple actors and shared state</li>
<li><strong>Known problem areas</strong>: Components with a history of subtle bugs</li>
</ol>
<h2 id="the-roi-of-mathematical-rigor">The ROI of Mathematical Rigor</h2>
<p><strong>Time Investment</strong>: ~1 day to write TLA+ specs<br>
<strong>Bug Found</strong>: Critical race condition<br>
<strong>Production Impact Avoided</strong>: Data inconsistencies, user confusion, debugging nightmares<br>
<strong>Team Learning</strong>: New appreciation for formal methods</p>
<p>TLA+ paid for itself the moment TLC printed that first invariant violation. Finding this bug in production would have meant:</p>
<ul>
<li>Emergency hotfix deployment</li>
<li>Data cleanup scripts</li>
<li>Customer support issues</li>
<li>Loss of confidence in the system</li>
</ul>
<p>Instead, we caught it before shipping any problematic code.</p>
<h2 id="getting-started-with-tla">Getting Started with TLA+</h2>
<p>Want to try TLA+? Here&rsquo;s how to start:</p>
<ol>
<li><strong>Install TLA+ Tools</strong>: Download from <a href="https://lamport.azurewebsites.net/tla/tools.html">TLA+ home page</a></li>
<li><strong>Start Small</strong>: Model a simple state machine from your system</li>
<li><strong>Focus on Invariants</strong>: What properties should always hold?</li>
<li><strong>Learn from Examples</strong>: <a href="https://github.com/tlaplus/Examples">TLA+ Examples repository</a></li>
<li><strong>Watch Lamport&rsquo;s Videos</strong>: <a href="https://lamport.azurewebsites.net/video/videos.html">TLA+ Video Course</a></li>
</ol>
<p>Don&rsquo;t model your entire system at once. Pick one tricky concurrent component and start there.</p>
<h2 id="conclusion-bugs-vs-mathematical-proof">Conclusion: Bugs vs. Mathematical Proof</h2>
<p>Software bugs are inevitable. But some bugs are more inevitable than others. Race conditions in concurrent systems aren&rsquo;t just likely. They&rsquo;re mathematically guaranteed if you have shared state and poor synchronization.</p>
<p>Traditional testing is like whack-a-mole with race conditions. You might catch some. You&rsquo;ll never be sure you got them all. Formal verification is different. It proves the moles can&rsquo;t exist in the first place.</p>
<p>TLA+ won&rsquo;t replace your testing strategy. But it&rsquo;s incredibly powerful for the trickiest bugs. The ones that hide between components. The ones that wait for perfect timing to corrupt your data.</p>
<p>Next time you design a concurrent system, spend a day on formal modeling. Your production systems will thank you. Your sleep schedule will too.</p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/tlaplus/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Tlaplus</a>
   </li>
  
   <li class="list di">
     <a href="/tags/formal-verification/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Formal-Verification</a>
   </li>
  
   <li class="list di">
     <a href="/tags/concurrency/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Concurrency</a>
   </li>
  
   <li class="list di">
     <a href="/tags/testing/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Testing</a>
   </li>
  
   <li class="list di">
     <a href="/tags/software-engineering/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Software-Engineering</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://lloydmoore.com/" >
    &copy;  Lloyd Moore 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
