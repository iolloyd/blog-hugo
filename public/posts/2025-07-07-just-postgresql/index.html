<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>PostgreSQL Will Do, or, You Don&#39;t Need Kafka | Lloyd Moore</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Before you spin up a three-node Kafka cluster, consider this: PostgreSQL can handle most pub-sub use cases perfectly well. And you&#39;ve probably already got it running.">
    <meta name="generator" content="Hugo 0.150.0">
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.2438bcafd7af9675c426d1a4afcd16cfff18e4e10f401071e45b5ccd3be40a0d.css" >




    


    
      

    

    

    
      <link rel="canonical" href="https://lloydmoore.com/posts/2025-07-07-just-postgresql/">
    

    <meta property="og:url" content="https://lloydmoore.com/posts/2025-07-07-just-postgresql/">
  <meta property="og:site_name" content="Lloyd Moore">
  <meta property="og:title" content="PostgreSQL Will Do, or, You Don&#39;t Need Kafka">
  <meta property="og:description" content="Before you spin up a three-node Kafka cluster, consider this: PostgreSQL can handle most pub-sub use cases perfectly well. And you&#39;ve probably already got it running.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-01-27T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-01-27T00:00:00+00:00">
    <meta property="article:tag" content="Postgresql">
    <meta property="article:tag" content="Kafka">
    <meta property="article:tag" content="Event-Streaming">
    <meta property="article:tag" content="Message-Queue">
    <meta property="article:tag" content="Architecture">

  <meta itemprop="name" content="PostgreSQL Will Do, or, You Don&#39;t Need Kafka">
  <meta itemprop="description" content="Before you spin up a three-node Kafka cluster, consider this: PostgreSQL can handle most pub-sub use cases perfectly well. And you&#39;ve probably already got it running.">
  <meta itemprop="datePublished" content="2025-01-27T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-01-27T00:00:00+00:00">
  <meta itemprop="wordCount" content="690">
  <meta itemprop="keywords" content="Postgresql,Kafka,Event-Streaming,Message-Queue,Architecture">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="PostgreSQL Will Do, or, You Don&#39;t Need Kafka">
  <meta name="twitter:description" content="Before you spin up a three-node Kafka cluster, consider this: PostgreSQL can handle most pub-sub use cases perfectly well. And you&#39;ve probably already got it running.">

      
    
	
  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Lloyd Moore
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">PostgreSQL Will Do, or, You Don&#39;t Need Kafka</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2025-01-27T00:00:00Z">January 27, 2025</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="you-dont-need-kafka-postgresql-will-do-just-fine">You Don&rsquo;t Need Kafka (PostgreSQL Will Do Just Fine)</h1>
<p>Every few months, someone on your team suggests adding Kafka. &ldquo;We need real-time event streaming,&rdquo; they say. &ldquo;We need to decouple our services.&rdquo;</p>
<p>Stop. Before you spin up a three-node Kafka cluster, consider PostgreSQL. It can handle most pub-sub use cases perfectly well. You&rsquo;ve probably already got it running.</p>
<h2 id="the-problem">The Problem</h2>
<p>Your application grows. Different parts need to know when things happen. The order service needs to tell the inventory service about new orders. The user service needs to notify the email service about registrations.</p>
<p>The textbook answer is simple: message queue, event streaming, Kafka.</p>
<p>But Kafka brings complexity. You need Zookeeper or KRaft. You need partitions, consumer groups, offset management. Suddenly you&rsquo;re debugging stuck messages. You&rsquo;re waiting for rebalancing to finish. Your disk fills up with log segments.</p>
<p>Meanwhile, PostgreSQL sits quietly handling your data. It provides ACID guarantees, battle-tested replication, and tooling your team already knows.</p>
<h2 id="why-postgresql-works-for-messaging">Why PostgreSQL Works for Messaging</h2>
<p>PostgreSQL has everything you need for messaging:</p>
<ul>
<li><strong>Durability</strong>: Write-ahead logging ensures messages survive crashes</li>
<li><strong>Ordering</strong>: SERIAL columns give you strict ordering</li>
<li><strong>Transactions</strong>: Publish events atomically with other database changes</li>
<li><strong>Queries</strong>: Find any message by time, type, or content</li>
<li><strong>Concurrency</strong>: SKIP LOCKED enables parallel consumers without coordination</li>
</ul>
<p>Most applications don&rsquo;t need millions of messages per second. They need hundreds or thousands. PostgreSQL handles that easily.</p>
<h2 id="the-basic-pattern">The Basic Pattern</h2>
<p>Create a simple events table:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> events (
</span></span><span style="display:flex;"><span>    id BIGSERIAL <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    created_at TIMESTAMPTZ <span style="color:#66d9ef">DEFAULT</span> NOW(),
</span></span><span style="display:flex;"><span>    event_type TEXT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    payload JSONB <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    processed_at TIMESTAMPTZ,
</span></span><span style="display:flex;"><span>    consumer_id TEXT
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_unprocessed <span style="color:#66d9ef">ON</span> events(id) 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> processed_at <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NULL</span>;
</span></span></code></pre></div><p>Publishing events is trivial:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> events (event_type, payload) 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">VALUES</span> (<span style="color:#e6db74">&#39;order.created&#39;</span>, <span style="color:#e6db74">&#39;{&#34;order_id&#34;: 123, &#34;total&#34;: 45.99}&#39;</span>);
</span></span></code></pre></div><p>Consuming uses PostgreSQL&rsquo;s row-level locking:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">UPDATE</span> events 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> processed_at <span style="color:#f92672">=</span> NOW(), consumer_id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;inventory-service&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> id <span style="color:#66d9ef">IN</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> id <span style="color:#66d9ef">FROM</span> events 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">WHERE</span> processed_at <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NULL</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">AND</span> event_type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;order.created&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> id 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">UPDATE</span> SKIP LOCKED
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>RETURNING <span style="color:#f92672">*</span>;
</span></span></code></pre></div><p>The FOR UPDATE SKIP LOCKED clause is magic. Multiple consumers can pull events concurrently without coordination. No consumer groups, no rebalancing. It just works.</p>
<h2 id="advanced-patterns">Advanced Patterns</h2>
<p>Need real-time notifications? Use LISTEN/NOTIFY:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- Publisher
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">NOTIFY</span> new_event, <span style="color:#e6db74">&#39;order.created&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Consumer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">LISTEN</span> new_event;
</span></span></code></pre></div><p>Need multiple consumer groups? Add a consumer_group column:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> event_consumers (
</span></span><span style="display:flex;"><span>    event_id BIGINT,
</span></span><span style="display:flex;"><span>    consumer_group TEXT,
</span></span><span style="display:flex;"><span>    processed_at TIMESTAMPTZ,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (event_id, consumer_group)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>Need event replay? Use a simple SELECT:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> events 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> created_at <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;2024-01-01&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">AND</span> event_type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;order.created&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> id;
</span></span></code></pre></div><p>Need retention policies? Partition by month:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> events_2024_03 PARTITION <span style="color:#66d9ef">OF</span> events
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">VALUES</span> <span style="color:#66d9ef">FROM</span> (<span style="color:#e6db74">&#39;2024-03-01&#39;</span>) <span style="color:#66d9ef">TO</span> (<span style="color:#e6db74">&#39;2024-04-01&#39;</span>);
</span></span></code></pre></div><h2 id="when-you-actually-need-kafka">When You Actually Need Kafka</h2>
<p>You do need Kafka in these cases:</p>
<ul>
<li><strong>Throughput</strong>: Millions of events per second</li>
<li><strong>Multiple datacentres</strong>: Built-in geo-replication</li>
<li><strong>Stream processing</strong>: Complex windowing and joins</li>
<li><strong>Long retention</strong>: Keeping months of high-volume data</li>
<li><strong>Existing ecosystem</strong>: Your team already runs Kafka</li>
</ul>
<p>These are exceptional cases. Most applications process thousands of events per second at peak. They need reliability more than raw throughput.</p>
<h2 id="the-implementation-path">The Implementation Path</h2>
<p>Start simple:</p>
<ol>
<li>Create the events table</li>
<li>Publish events alongside your transactions</li>
<li>Write a consumer loop with SKIP LOCKED</li>
<li>Monitor with normal PostgreSQL tools</li>
</ol>
<p>When you need more:</p>
<ol>
<li>Add LISTEN/NOTIFY for lower latency</li>
<li>Partition old events to archive tables</li>
<li>Create materialized views for analytics</li>
<li>Add read replicas for consumer scaling</li>
</ol>
<h2 id="the-real-win">The Real Win</h2>
<p>The biggest advantage isn&rsquo;t technical. It&rsquo;s operational. Your team knows PostgreSQL. It&rsquo;s easier to learn, deploy and maintain than Kafka. Your monitoring covers PostgreSQL. Your backups include PostgreSQL.</p>
<p>When something goes wrong at 3am, you debug familiar SQL. You don&rsquo;t decipher consumer group rebalancing.</p>
<p>You write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> events <span style="color:#66d9ef">WHERE</span> processed_at <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NULL</span>. 
</span></span></code></pre></div><p>Not:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kafka-consumer-groups --describe --group my-consumer --bootstrap-server localhost:9092.
</span></span></code></pre></div><h2 id="making-the-choice">Making the Choice</h2>
<p>Next time someone suggests Kafka, ask these questions:</p>
<ul>
<li>How many events per second? (Really?)</li>
<li>Do we need multi-datacentre replication?</li>
<li>Are we doing complex stream processing?</li>
<li>Can we tolerate 100ms latency?</li>
</ul>
<p>If you answer &ldquo;thousands&rdquo;, &ldquo;no&rdquo;, &ldquo;no&rdquo;, and &ldquo;yes&rdquo; - you don&rsquo;t need Kafka. You need PostgreSQL.</p>
<p>This isn&rsquo;t anti-Kafka. Kafka&rsquo;s brilliant for the problems it solves. But those problems are rarer than we think. Most of us build CRUD apps with some events on the side. PostgreSQL handles that beautifully.</p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/postgresql/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Postgresql</a>
   </li>
  
   <li class="list di">
     <a href="/tags/kafka/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Kafka</a>
   </li>
  
   <li class="list di">
     <a href="/tags/event-streaming/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Event-Streaming</a>
   </li>
  
   <li class="list di">
     <a href="/tags/message-queue/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Message-Queue</a>
   </li>
  
   <li class="list di">
     <a href="/tags/architecture/" class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Architecture</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="https://lloydmoore.com/" >
    &copy;  Lloyd Moore 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
